<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>How to Train Your Dragon - Dragon Profiles</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Base styles - keep as original as possible */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box; /* Crucial for consistent sizing */
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: Black;
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            overflow-x: hidden; /* Prevent horizontal scroll */
            touch-action: pan-y; /* Allow vertical scroll, prevent horizontal on body */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .milkybar-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px 10px;
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .milkybar-header {
            text-align: center;
            margin-bottom: 20px;
            padding: 0 5px;
            width: 100%;
        }

        .milkybar-header h1 {
            color: #d4a017;
            font-size: clamp(1.8rem, 6vw, 3.5rem);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.1);
            margin-bottom: 5px;
            font-weight: 800;
            line-height: 1.2;
        }

        .milkybar-header p {
            color: #8c6d3e;
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: bold;
            line-height: 1.3;
        }

        .dragon-carousel {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }

        /* New wrapper to stabilize nav button positioning */
        .carousel-visuals-wrapper {
            position: relative;
        }

        /* 3D Carousel Container */
        .image-carousel {
            position: relative;
            width: 100%;
            height: auto;
            min-height: 400px; /* Ensure enough space for slides */
            margin: 20px auto;
            perspective: 1200px; /* Crucial for 3D effect */
            overflow: hidden;
            transform-style: preserve-3d; /* Needed for child 3D transforms */
            /* INCREASED PADDING to prevent top cropping */
            padding: 60px 0;
        }

        .image-track {
            display: flex; /* Essential for horizontal layout */
            height: 100%;
            transition: transform 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
            align-items: center;
            transform-style: preserve-3d; /* Inherits perspective */
        }

        /* 3D Slide Styling */
        .image-slide {
            flex-shrink: 0; /* Prevent slides from shrinking */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform-style: preserve-3d; /* Allows 3D transforms on children */
            opacity: 0; /* Hidden by default, shown by JS */
            pointer-events: none; /* Not interactable by default */
            will-change: transform, opacity, filter;
            padding: 0 10px; /* Creates the visual gap between slides */
        }

        .dragon-frame {
            width: clamp(150px, 40vw, 250px);
            height: clamp(200px, 53vw, 350px);
            position: relative;
            overflow: hidden; /* Crucial for reflection effect */
            border-radius: 15px; /* Added for a softer glass look */

            /* Glassmorphism Effect */
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); /* For Safari */
            border: 2px solid rgba(255, 255, 255, 0.2);

            transition: all 0.6s cubic-bezier(0.25, 0.1, 0.25, 1), box-shadow 0.6s ease-in-out, border-color 0.6s ease-in-out;
            transform-style: preserve-3d;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5),
                        0 0 10px rgba(255, 255, 255, 0.3);
            will-change: transform;
        }

        /* Reflection Keyframes */
        @keyframes glass-reflection {
            0% {
                transform: translateX(-120%) skewX(-20deg);
            }
            100% {
                transform: translateX(220%) skewX(-20deg);
            }
        }

        /* Reflection pseudo-element */
        .dragon-frame::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 100%;
            background: linear-gradient(
                to right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.2) 35%,
                rgba(255, 255, 255, 0.4) 50%,
                rgba(255, 255, 255, 0.2) 65%,
                rgba(255, 255, 255, 0) 100%
            );
            animation: glass-reflection 3s linear infinite;
            z-index: -1; /* Ensures this is behind all content */
            pointer-events: none; /* Make sure it doesn't interfere with clicks */
            filter: blur(1px); /* Add a subtle blur */
            will-change: transform;
        }


        @keyframes glowing-colors {
            0% {
                border-color: rgba(255, 0, 255, 0.8);
                box-shadow:
                    0 0 10px 2px rgba(255, 0, 255, 0.6),
                    0 0 20px 5px rgba(255, 0, 255, 0.4),
                    0 0 30px 10px rgba(255, 0, 255, 0.2),
                    0 15px 40px rgba(140, 109, 62, 0.5);
            }
            25% {
                border-color: rgba(0, 255, 255, 0.8);
                box-shadow:
                    0 0 10px 2px rgba(0, 255, 255, 0.6),
                    0 0 20px 5px rgba(0, 255, 255, 0.4),
                    0 0 30px 10px rgba(0, 255, 255, 0.2),
                    0 15px 40px rgba(140, 109, 62, 0.5);
            }
            50% {
                border-color: rgba(255, 255, 0, 0.8);
                box-shadow:
                    0 0 10px 2px rgba(255, 255, 0, 0.6),
                    0 0 20px 5px rgba(255, 255, 0, 0.4),
                    0 0 30px 10px rgba(255, 255, 0, 0.2),
                    0 15px 40px rgba(140, 109, 62, 0.5);
            }
            75% {
                border-color: rgba(0, 255, 0, 0.8);
                box-shadow:
                    0 0 10px 2px rgba(0, 255, 0, 0.6),
                    0 0 20px 5px rgba(0, 255, 0, 0.4),
                    0 0 30px 10px rgba(0, 255, 0, 0.2),
                    0 15px 40px rgba(140, 109, 62, 0.5);
            }
            100% {
                border-color: rgba(255, 0, 255, 0.8);
                box-shadow:
                    0 0 10px 2px rgba(255, 0, 255, 0.6),
                    0 0 20px 5px rgba(255, 0, 255, 0.4),
                    0 0 30px 10px rgba(255, 0, 255, 0.2),
                    0 15px 40px rgba(140, 109, 62, 0.5);
            }
        }


/* Updated Keyframes for Red Neon Light Trail Effect on Text */
    @keyframes neon-light-trail {
        0%, 100% {
            text-shadow:
                0 0 5px #FFA500,   /* Red base glow */
                0 0 10px #FFA500,
                0 0 20px rgba(255, 0, 0, 0.6), /* Wider red glow */
                0 0 30px rgba(255, 0, 0, 0.4);
        }
        25% {
            text-shadow:
                -2px -2px 5px #FFA500, /* Lighter Red trail up-left */
                -4px -4px 10px #FFA500,
                -6px -6px 20px rgba(255, 51, 51, 0.6),
                -8px -8px 30px rgba(255, 51, 51, 0.4);
        }
        50% {
            text-shadow:
                0 0 5px #FF0000,   /* Red base glow */
                0 0 10px #FF0000,
                0 0 20px rgba(255, 0, 0, 0.6),
                0 0 30px rgba(255, 0, 0, 0.4);
        }
        75% {
            text-shadow:
                2px 2px 5px #FFA500, /* Darker Red trail down-right */
                4px 4px 10px #FFA500,
                6px 6px 20px rgba(204, 0, 0, 0.6),
                8px 8px 30px rgba(204, 0, 0, 0.4);
        }
    }

    /* Apply the neon light trail animation */
    .dragon-frame.flipped .dragon-back-text {
        animation: neon-light-trail 4s infinite ease-in-out;
    }


        .dragon-frame.flipped {
            transform: translateY(-5px) scale(1.02) translateZ(50px);
            z-index: 20; /* Ensure flipped card is above others */
            animation: glowing-colors 5s infinite alternate ease-in-out;
        }

        .dragon-frame-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            will-change: transform;
        }

        .dragon-frame.flipped .dragon-frame-inner {
            transform: rotateY(180deg);
        }

        /* Base styles for front and back faces */
        .dragon-front, .dragon-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Hide backface when rotated */
            -webkit-backface-visibility: hidden;
            top: 0;
            left: 0;
            display: flex; /* Enable flexbox for positioning content */
        }

        .dragon-front {
            transition: opacity 0.3s ease 0.3s;
            align-items: center; /* Vertically center content on the front */
            justify-content: center; /* Horizontally center content on the front */
        }

        .dragon-frame.flipped .dragon-front {
             opacity: 0;
             pointer-events: none;
        }

        /* --- MODIFICATION FOR ISSUE #2 --- */
        .dragon-back {
            transform: rotateY(180deg);
            background: transparent;
            overflow: hidden;
            flex-direction: column;
            align-items: center; /* Horizontally center content */
            justify-content: flex-start; /* Vertically align content to the TOP */
            padding: 10px 5px 5px 5px; /* Add padding, especially to the top */
            gap: 8px; /* Space between media and controls */
        }

        /* Styles apply to both images and videos */
        .dragon-content {
            width: 100%;
            max-height: calc(100% - 40px); /* Reserve space for controls and gap */
            object-fit: contain;
            display: block;
            position: relative;
            z-index: 1;
            background-color: transparent;
            border-radius: 10px;
        }

        .dragon-back img.dragon-content {
            cursor: zoom-in;
        }

        .dragon-back .dragon-content {
            box-shadow:
                0px 8px 20px rgba(0, 0, 0, 0.4),
                0px 0px 10px rgba(255, 255, 255, 0.6),
                inset 0px 0px 8px rgba(255, 255, 255, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease-in-out;
        }

        /* NEW: Floating text area on the back of the flip card */
        .dragon-back-text {
            position: absolute;
            top: 60%; /* Positioned a bit lower */
            left: 50%;
            transform: translate(-50%, -50%); /* Center both horizontally and vertically */
            width: calc(100% - 20px); /* Adjust width to fit within padding */
            max-height: 50%; /* Limit height to prevent excessive overlap with media */
            background: rgba(0, 0, 0, 0.6); /* Slightly darker background */
	    Font-family: FBI;
            color: White; /* Text color matching header */
            padding: 5px 8px;
            border-radius: 8px;
            /* --- ADJUSTED FOR LARGER FONT SIZE ON ALL SCREENS, ESPECIALLY MOBILE --- */
            font-size: clamp(1.6rem, 5.5vw, 3rem); /* Significantly increased values */
            /* --- END ADJUSTMENT --- */
            text-align: center;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 2; /* Ensure it's above the media but below reflections/other overlays */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease-in-out;

            /* Make it scrollable without scrollbars */
            overflow-y: auto; /* Enable vertical scrolling when content overflows */
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none; /* Firefox */
        }

        /* Hide scrollbar for Chrome, Safari and Opera */
        .dragon-back-text::-webkit-scrollbar {
            display: none;
        }

        .dragon-frame.flipped .dragon-back-text {
            opacity: 1; /* Show when flipped */
        }


        /* Current Slide (not flipped) - 3D Positioning and Neon Glow */
        .image-slide.current {
            transform: translateZ(0) scale(1.1);
            opacity: 1;
            z-index: 10;
            pointer-events: auto;
        }
        .image-slide.current .dragon-frame:not(.flipped) {
            transform: translateY(-15px);
            animation: static-glowing 2s infinite alternate ease-in-out;
            box-shadow: 0 10px 30px rgba(140, 109, 62, 0.4);
        }

        /* Adjacent Slides */
        .image-slide.prev {
            transform: translateZ(-100px) rotateY(15deg);
            opacity: 0.5;
            z-index: 5;
            pointer-events: auto;
        }
        .image-slide.next {
            transform: translateZ(-100px) rotateY(-15deg);
            opacity: 0.5;
            z-index: 5;
            pointer-events: auto;
        }

        .image-slide.prev .dragon-frame:not(.flipped),
        .image-slide.next .dragon-frame:not(.flipped) {
            transform: none;
            animation: none;
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }

        /* Far Adjacent Slides */
        .image-slide.far-prev {
            transform: translateZ(-250px) rotateY(25deg);
            opacity: 0.1;
            z-index: 2;
            pointer-events: none;
        }
        .image-slide.far-next {
            transform: translateZ(-250px) rotateY(-25deg);
            opacity: 0.1;
            z-index: 2;
            pointer-events: none;
        }

        .image-slide.far-prev .dragon-frame:not(.flipped),
        .image-slide.far-next .dragon-frame:not(.flipped) {
            transform: none;
            animation: none;
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: none;
        }

        @keyframes static-glowing {
            0% {
                border-color: rgba(255, 215, 0, 0.8);
                box-shadow:
                    0 0 8px 1px rgba(255, 215, 0, 0.6),
                    0 0 15px 3px rgba(255, 215, 0, 0.4);
            }
            50% {
                border-color: rgba(255, 255, 255, 0.9);
                box-shadow:
                    0 0 12px 2px rgba(255, 255, 255, 0.8),
                    0 0 20px 4px rgba(255, 255, 255, 0.6);
            }
            100% {
                border-color: rgba(255, 215, 0, 0.8);
                box-shadow:
                    0 0 8px 1px rgba(255, 215, 0, 0.6),
                    0 0 15px 3px rgba(255, 215, 0, 0.4);
            }
        }

        .info-section-wrapper {
            width: 100%;
            max-width: 600px;
            margin: 20px auto 5px auto;
            text-align: center;
            position: relative;
            z-index: 10;
        }

        .info-section {
            opacity: 1;
            height: auto;
            overflow: visible;
            transition: none; /* No transition for content, updated instantly */
        }

        .dragon-name {
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            font-weight: 800;
            color: #8c6d3e;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            line-height: 1;
            text-shadow: 1px 1px 0px rgba(0,0,0,0.1);
        }

        .dragon-description {
            font-size: clamp(1rem, 3vw, 1.2rem);
            line-height: 1.4;
            color: #8c6d3e;
            max-width: 600px;
            margin: 0 auto;
            font-weight: 500;
        }

        /* Holographic Navigation Button Styles - Base */
        .milkybar-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: clamp(45px, 10vw, 60px);
            height: clamp(45px, 10vw, 60px);
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            cursor: pointer;
            font-size: clamp(1.3rem, 4vw, 2rem);
            color: #0ff;
            z-index: 30; /* Ensure buttons are always on top */
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), 0 0 20px rgba(0, 255, 255, 0.1);
            overflow: hidden;
            transition: all 0.5s ease;
            text-shadow: 0 0 5px #0ff;
            outline: none;
        }

        .milkybar-nav::before {
            content: '';
            position: absolute;
            top: -100%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                0deg,
                transparent,
                transparent 40%,
                rgba(0, 255, 255, 0.5)
            );
            transform: rotate(-45deg);
            transition: all 0.5s ease;
            opacity: 0;
            z-index: 1;
            border-radius: 50%;
            pointer-events: none;
        }

        .milkybar-nav i {
            position: relative;
            z-index: 2;
        }

        .milkybar-nav:hover {
            transform: translateY(-50%) scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7), 0 0 40px rgba(0, 255, 255, 0.4);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .milkybar-nav:hover::before {
            opacity: 1;
            transform: rotate(-45deg) translateY(120%);
        }

        .milkybar-nav:active {
            transform: translateY(-50%) scale(0.95);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), 0 0 20px rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.5);
        }
        .milkybar-nav:active::before {
            opacity: 1;
            transform: rotate(-45deg) translateY(120%);
        }

        .milkybar-nav:focus-visible {
            outline: 2px solid rgba(0, 255, 255, 0.8);
            outline-offset: 3px;
        }

        .milkybar-nav:not(:hover):not(:active):not(:focus-visible) {
            transform: translateY(-50%) scale(1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), 0 0 20px rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.5);
        }
        .milkybar-nav:not(:hover):not(:active):not(:focus-visible)::before {
            opacity: 0;
            transform: rotate(-45deg) translateY(-100%);
        }

        @keyframes temporary-glow {
            0% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.7), 0 0 30px rgba(0, 255, 255, 0.4);
                border-color: rgba(0, 255, 255, 0.8);
            }
            75% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.7), 0 0 30px rgba(0, 255, 255, 0.4);
                border-color: rgba(0, 255, 255, 0.8);
            }
            100% {
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), 0 0 20px rgba(0, 255, 255, 0.1);
                border-color: rgba(0, 255, 255, 0.5);
            }
        }

        @media (hover: none) {
            .milkybar-nav:hover {
                transform: translateY(-50%) scale(1);
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), 0 0 20px rgba(0, 255, 255, 0.1);
                border-color: rgba(0, 255, 255, 0.5);
            }
            .milkybar-nav.glow-active {
                animation: temporary-glow 1.2s forwards;
            }
        }

        .milkybar-prev {
            left: 5px;
        }

        .milkybar-next {
            right: 5px;
        }

        .milkybar-dots {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
            padding: 0 10px;
        }

        .milkybar-dot {
            width: clamp(10px, 2.5vw, 14px);
            height: clamp(10px, 2.5vw, 14px);
            margin: 5px;
            background-color: #f0d9a7;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #d4a017;
        }

        .milkybar-dot.active {
            background-color: #d4a017;
            transform: scale(1.2);
        }

        .media-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
            cursor: zoom-out;
        }

        .media-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .media-overlay .overlay-content {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            cursor: default;
        }

        .media-overlay .overlay-content.zoomable-image {
            cursor: zoom-out;
        }

        .media-overlay .overlay-content[data-type="video"] {
            cursor: auto;
        }

        @media (max-width: 575px) {
            .image-slide { width: 100%; }
        }
        @media (min-width: 576px) {
            .image-slide { width: 50%; }
            .milkybar-prev { left: -15px; }
            .milkybar-next { right: -15px; }
        }
        @media (min-width: 768px) {
            .image-slide { width: 33.333%; }
            .milkybar-prev { left: -25px; }
            .milkybar-next { right: -25px; }
        }
        @media (min-width: 992px) {
            .image-slide { width: 25%; }
            .milkybar-prev { left: -30px; }
            .milkybar-next { right: -30px; }
        }
        @media (max-width: 480px) and (orientation: portrait) {
            .image-carousel { min-height: 350px; }
            .dragon-frame { width: 70vw; height: 90vw; max-width: 250px; max-height: 350px; }
            .milkybar-nav { width: 40px; height: 40px; }
            /* Adjusted font-size for smaller portrait mobile screens */
            .dragon-back-text { font-size: clamp(1.4rem, 4vw, 2.5rem); padding: 4px 6px; }
        }
        @media (max-height: 480px) and (orientation: landscape) {
            .milkybar-container { padding: 10px; }
            .milkybar-header h1 { font-size: clamp(1.5rem, 5vw, 2.5rem); }
            .milkybar-header p { font-size: clamp(0.8rem, 2.5vw, 1.2rem); }
            .image-carousel { min-height: 250px; }
            .dragon-frame { width: clamp(120px, 30vw, 200px); height: clamp(150px, 40vw, 280px); }
            .milkybar-nav { width: 30px; height: 30px; font-size: 1rem; }
            .milkybar-prev { left: -5px; }
            .milkybar-next { right: -5px; }
            .info-section-wrapper { margin-top: 10px; }
            .dragon-name { font-size: clamp(1.5rem, 4vw, 2rem); }
            .dragon-description { font-size: clamp(0.9rem, 2.5vw, 1.1rem); }
            /* Adjusted font-size for landscape mobile screens */
            .dragon-back-text { font-size: clamp(1.2rem, 3.5vw, 2rem); padding: 4px 6px; }
        }
        @media (max-width: 992px) and (min-width: 768px) and (hover: none) {
            .image-slide { width: 33.333% !important; }
            .milkybar-nav { width: 40px !important; height: 40px !important; }
            .milkybar-prev { left: -10px !important; }
            .milkybar-next { right: -10px !important; }
            .dragon-frame { width: clamp(180px, 30vw, 220px) !important; height: clamp(240px, 40vw, 300px) !important; }
            /* Adjusted font-size for larger tablets in portrait */
            .dragon-back-text { font-size: clamp(1.5rem, 4.8vw, 2.8rem); }
        }
    </style>
</head>
<body>
    <div class="milkybar-container">
        <div class="milkybar-header">
            <h1>How to Train Your Dragon</h1>
            <p>Meet the Dragon Collection</p>
        </div>

        <div class="dragon-carousel">
            <div class="carousel-visuals-wrapper">
                <div class="image-carousel">
                    <div class="image-track" id="imageTrack"></div>
                </div>
                <button class="milkybar-nav milkybar-prev" id="milkybarPrev">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <button class="milkybar-nav milkybar-next" id="milkybarNext">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>

            <div class="info-section-wrapper">
                <div id="infoSections"></div>
            </div>
            <div class="milkybar-dots" id="milkybarDots"></div>
        </div>
    </div>

    <div class="media-overlay" id="mediaOverlay">
         <div id="overlayContentWrapper"></div>
    </div>


    <script>
        const dragonData = [
            {
                front: { type: 'image', src: 'https://preview.redd.it/how-useful-itachis-mangekyou-sharingan-would-be-in-real-life-v0-gftkovseo4rc1.jpeg?auto=webp&s=d924df6e1b4300a1da65fcf59fdfc118429387ae' },
                back: { type: 'image', src: 'https://i.pinimg.com/originals/a6/61/93/a661935c4126d02290d5be9dfbd61e59.gif' },
                name: 'GRONCKLE',
                description: 'The Gronckle is a slow, bumbling dragon that buzzes around clumsily like a bumblebee. Despite its awkward appearance, it has a powerful digestive system that allows it to eat rocks and produce molten lava.'
            },
            {
                front: { type: 'image', src: 'https://static.wikia.nocookie.net/howtotrainyourdragon/images/3/3f/HTTYD_Hideous_Zippleback.png/revision/latest/scale-to-width-down/1000?cb=20140807192912' },
                back: { type: 'image', src: 'https://static.wikia.nocookie.net/howtotrainyourdragon/images/1/1e/HTTYD_Hideous_Zippleback_Profile.png/revision/latest?cb=20140807192913', text: 'Each head of a Hideous Zippleback has a distinct role: one produces gas, the other ignites it. This two-headed dragon communicates through a series of hisses and growls between its heads, often leading to comical arguments. They are surprisingly agile in the air, using their two tails for balance. Despite their intimidating appearance, they can be quite playful once trained, often engaging in mischievous pranks.' },
                name: 'HIDEOUS ZIPPLEBACK',
                description: 'The Hideous Zippleback is a two-headed dragon where the two heads are like squabbling, bickering twins. One head breathes flammable gas while the other creates sparks to ignite it, making them a dangerous combination.'
            },
            {
                front: { type: 'image', src: 'https://static.wikia.nocookie.net/howtotrainyourdragon/images/9/9a/Toothless_HTTYD.png/revision/latest/scale-to-width-down/1000?cb=20140807192856' },
                back: { type: 'video', src: 'https://www.w3schools.com/html/movie.mp4', poster: 'https://static.wikia.nocookie.net/howtotrainyourdragon/images/7/76/HTTYD_Night_Fury_Profile.png/revision/latest?cb=20140807192857', text: 'Night Furies are incredibly rare and known for their unmatched speed and plasma blasts. Their sleek, dark scales allow them to blend seamlessly into the night sky, making them nearly invisible. They are highly intelligent and bond deeply with their riders, displaying loyalty and fierce protectiveness. Their plasma blasts are extremely powerful and precise, capable of destroying targets with pinpoint accuracy. Finding a Night Fury is considered a legendary feat.' },
                name: 'NIGHT FURY',
                description: 'The Night Fury is the most elusive and mysterious of all dragons. With incredible speed and stealth capabilities, it was considered the unholy offspring of lightning and death itself before being understood.'
            },
            {
                front: { type: 'image', src: 'https://static.wikia.nocookie.net/howtotrainyourdragon/images/5/5b/HTTYD_Deadly_Nadder.png/revision/latest/scale-to-width-down/1000?cb=20140807192845' },
                back: { type: 'image', src: 'https://static.wikia.nocookie.net/howtotrainyourdragon/images/3/3f/HTTYD_Deadly_Nadder_Profile.png/revision/latest?cb=20140807192846', text: 'Deadly Nadders are vain but beautiful dragons, famous for their venomous spines and keen sense of smell. They have a distinctive, bright coloration and a large, expressive face. Their long, sharp tail spines can be launched with great force, acting as a potent defensive mechanism. Despite their beauty, they are quick to anger and possess a "blinding class" attack where they temporarily blind opponents with a flash of light from their eyes. They are highly agile flyers and intelligent hunters.' },
                name: 'DEADLY NADDA',
                description: 'The Deadly Nadder is covered in sharp spines that it can shoot like arrows when threatened. Despite its defensive capabilities, it is actually quite friendly and intelligent when properly trained.'
            }
        ];

        const imageTrack = document.getElementById('imageTrack');
        const infoSectionsContainer = document.getElementById('infoSections');
        const dotsContainer = document.getElementById('milkybarDots');
        const prevButton = document.getElementById('milkybarPrev');
        const nextButton = document.getElementById('milkybarNext');
        const mediaOverlay = document.getElementById('mediaOverlay');
        const overlayContentWrapper = document.getElementById('overlayContentWrapper');

        let currentIndex = 0;
        let slideFullWidth = 0;
        let videoTimeUpdateIntervals = {}; // To store intervals for saving video time

        // Keys for localStorage
        const LOCAL_STORAGE_CURRENT_INDEX = 'milkybarCarouselCurrentIndex';
        const LOCAL_STORAGE_FLIPPED_STATE = 'milkybarCarouselFlippedState'; // Stores an object like {0: true, 1: false}
        const LOCAL_STORAGE_VIDEO_TIME = 'milkybarCarouselVideoTime_'; // Suffix with index
        const LOCAL_STORAGE_OVERLAY_VISIBLE = 'milkybarCarouselOverlayVisible';
        const LOCAL_STORAGE_OVERLAY_CONTENT_SRC = 'milkybarCarouselOverlaySrc';
        const LOCAL_STORAGE_OVERLAY_CONTENT_TYPE = 'milkybarCarouselOverlayType';
        const LOCAL_STORAGE_OVERLAY_CONTENT_CURRENT_TIME = 'milkybarCarouselOverlayCurrentTime';


        function initCarousel() {
            imageTrack.innerHTML = '';
            infoSectionsContainer.innerHTML = '';
            dotsContainer.innerHTML = '';

            // Retrieve saved states
            currentIndex = parseInt(localStorage.getItem(LOCAL_STORAGE_CURRENT_INDEX) || '0');
            let savedFlippedState = JSON.parse(localStorage.getItem(LOCAL_STORAGE_FLIPPED_STATE) || '{}');
            if (Object.keys(savedFlippedState).length !== dragonData.length) {
                // If data schema changed or first load, reset flipped state
                savedFlippedState = {};
                dragonData.forEach((_, i) => savedFlippedState[i] = false);
                localStorage.setItem(LOCAL_STORAGE_FLIPPED_STATE, JSON.stringify(savedFlippedState));
            }

            dragonData.forEach((dragon, index) => {
                const imageSlide = document.createElement('div');
                imageSlide.className = 'image-slide';
                imageSlide.dataset.index = index;

                const frame = document.createElement('div');
                frame.className = 'dragon-frame';

                const frameInner = document.createElement('div');
                frameInner.className = 'dragon-frame-inner';

                const front = document.createElement('div');
                front.className = 'dragon-front';

                let frontContentElement;
                if (dragon.front.type === 'video') {
                    frontContentElement = document.createElement('video');
                    frontContentElement.src = dragon.front.src;
                    frontContentElement.loop = true;
                    frontContentElement.playsInline = true;
                    frontContentElement.muted = true; // Always muted on front
                    if (dragon.front.poster) frontContentElement.poster = dragon.front.poster;
                    // Preload metadata to avoid errors on first play attempts
                    frontContentElement.preload = 'metadata';
                } else {
                    frontContentElement = document.createElement('img');
                    frontContentElement.src = dragon.front.src;
                }
                frontContentElement.alt = dragon.name;
                frontContentElement.className = 'dragon-content';
                frontContentElement.dataset.type = dragon.front.type;

                const back = document.createElement('div');
                back.className = 'dragon-back';

                let backContentElement;
                if (dragon.back.type === 'video') {
                    backContentElement = document.createElement('video');
                    backContentElement.src = dragon.back.src;
                    backContentElement.loop = true;
                    backContentElement.playsInline = true;
                    backContentElement.muted = true; // Start muted, unmuted when flipped
                    backContentElement.controls = true;
                    backContentElement.controlsList = "nodownload nofullscreen";
                    if (dragon.back.poster) backContentElement.poster = dragon.back.poster;
                    backContentElement.preload = 'metadata'; // Preload metadata

                    // Restore video playback time
                    const savedVideoTime = parseFloat(localStorage.getItem(LOCAL_STORAGE_VIDEO_TIME + index) || '0');
                    if (savedVideoTime > 0) {
                        backContentElement.currentTime = savedVideoTime;
                    }

                    // Save video playback time periodically and on events
                    const saveVideoTime = () => {
                        localStorage.setItem(LOCAL_STORAGE_VIDEO_TIME + index, backContentElement.currentTime.toString());
                    };

                    backContentElement.addEventListener('play', () => {
                        // Clear any existing interval for this video
                        if (videoTimeUpdateIntervals[index]) {
                            clearInterval(videoTimeUpdateIntervals[index]);
                        }
                        // Set interval to save time every 5 seconds
                        videoTimeUpdateIntervals[index] = setInterval(saveVideoTime, 5000);
                    });
                    backContentElement.addEventListener('pause', () => {
                        clearInterval(videoTimeUpdateIntervals[index]); // Clear interval on pause
                        saveVideoTime(); // Save immediately on pause
                    });
                    backContentElement.addEventListener('ended', () => {
                        clearInterval(videoTimeUpdateIntervals[index]); // Clear interval on end
                        localStorage.setItem(LOCAL_STORAGE_VIDEO_TIME + index, '0'); // Reset on end
                    });

                } else {
                    backContentElement = document.createElement('img');
                    backContentElement.src = dragon.back.src;
                }
                backContentElement.alt = `${dragon.name} back view`;
                backContentElement.className = 'dragon-content';
                backContentElement.dataset.type = dragon.back.type;
                backContentElement.dataset.src = dragon.back.src; // Store original src for overlay

                back.appendChild(backContentElement);

                // Add the floating text area
                if (dragon.back.text) {
                    const backText = document.createElement('div');
                    backText.className = 'dragon-back-text';
                    backText.textContent = dragon.back.text;
                    back.appendChild(backText);
                }

                // Add double click to zoom for images only
                if (dragon.back.type === 'image') {
                    backContentElement.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        showMediaInOverlay(backContentElement.src, backContentElement.dataset.type);
                    });
                }

                front.appendChild(frontContentElement);
                frameInner.appendChild(front);
                frameInner.appendChild(back);
                frame.appendChild(frameInner);

                // Restore flipped state immediately after creation
                if (savedFlippedState[index]) {
                    frame.classList.add('flipped');
                }

                frame.addEventListener('click', function(e) {
                    if (imageSlide.classList.contains('current')) {
                        e.stopPropagation();
                        const isFlippingToBack = !this.classList.contains('flipped');
                        this.classList.toggle('flipped');

                        const currentBackVideo = this.querySelector('.dragon-back video');
                        const currentFrontVideo = this.querySelector('.dragon-front video');

                        if (isFlippingToBack) {
                            hideMediaOverlay(); // Ensure overlay is hidden when flipping to back
                            if (currentBackVideo) {
                                currentBackVideo.muted = false; // Unmute when flipped to back
                                currentBackVideo.play().catch(error => console.warn("Autoplay with sound was prevented:", error));
                            }
                            if (currentFrontVideo) currentFrontVideo.pause();
                        } else { // Flipped back to front
                            if (currentBackVideo) {
                                currentBackVideo.pause();
                                currentBackVideo.currentTime = 0; // Reset video on flip back
                                currentBackVideo.muted = true;
                                localStorage.setItem(LOCAL_STORAGE_VIDEO_TIME + index, '0'); // Reset saved time
                            }
                            if (currentFrontVideo) {
                                frontContentElement.muted = true; // Ensure front video is muted
                                currentFrontVideo.play().catch(error => console.warn("Front video autoplay prevented:", error));
                            }
                        }
                        // Save flipped state
                        savedFlippedState[index] = this.classList.contains('flipped');
                        localStorage.setItem(LOCAL_STORAGE_FLIPPED_STATE, JSON.stringify(savedFlippedState));

                    } else {
                        goToSlide(parseInt(imageSlide.dataset.index));
                    }
                });

                imageSlide.appendChild(frame);
                imageTrack.appendChild(imageSlide);

                const dot = document.createElement('div');
                dot.className = 'milkybar-dot';
                dot.dataset.index = index;
                dot.addEventListener('click', () => goToSlide(index));
                dotsContainer.appendChild(dot);
            });

            const infoSectionContent = document.createElement('div');
            infoSectionContent.className = 'info-section';
            infoSectionsContainer.appendChild(infoSectionContent);

            updateCarousel();
        }

        function showMediaInOverlay(src, type, initialTime = 0) {
            overlayContentWrapper.innerHTML = '';
            let mediaElement;

            if (type === 'video') {
                mediaElement = document.createElement('video');
                mediaElement.src = src;
                mediaElement.loop = true;
                mediaElement.playsInline = true;
                mediaElement.controls = true;
                mediaElement.controlsList = "nodownload nofullscreen";
                mediaElement.muted = false; // Unmute in overlay
                mediaElement.preload = 'auto'; // Preload for better experience in overlay

                if (initialTime > 0) {
                    mediaElement.currentTime = initialTime;
                }

                mediaElement.addEventListener('play', () => {
                    localStorage.setItem(LOCAL_STORAGE_OVERLAY_CONTENT_CURRENT_TIME, mediaElement.currentTime.toString());
                });
                mediaElement.addEventListener('pause', () => {
                    localStorage.setItem(LOCAL_STORAGE_OVERLAY_CONTENT_CURRENT_TIME, mediaElement.currentTime.toString());
                });
                mediaElement.addEventListener('ended', () => {
                    localStorage.setItem(LOCAL_STORAGE_OVERLAY_CONTENT_CURRENT_TIME, '0');
                });
                mediaElement.addEventListener('timeupdate', () => {
                    if (Math.floor(mediaElement.currentTime) % 5 === 0 && mediaElement.lastSavedTime !== Math.floor(mediaElement.currentTime)) {
                        localStorage.setItem(LOCAL_STORAGE_OVERLAY_CONTENT_CURRENT_TIME, mediaElement.currentTime.toString());
                        mediaElement.lastSavedTime = Math.floor(mediaElement.currentTime);
                    }
                });

                // Ensure video starts playing if it was playing when overlay was opened
                mediaElement.play().catch(e => console.warn("Overlay video autoplay prevented:", e));

            } else { // image
                mediaElement = document.createElement('img');
                mediaElement.src = src;
                mediaElement.classList.add('zoomable-image');
                mediaElement.addEventListener('dblclick', hideMediaOverlay);
            }
            mediaElement.className = 'overlay-content';
            mediaElement.dataset.type = type; // Store type
            mediaElement.dataset.src = src;   // Store src

            overlayContentWrapper.appendChild(mediaElement);
            mediaOverlay.classList.add('visible');

            // Save overlay state
            localStorage.setItem(LOCAL_STORAGE_OVERLAY_VISIBLE, 'true');
            localStorage.setItem(LOCAL_STORAGE_OVERLAY_CONTENT_SRC, src);
            localStorage.setItem(LOCAL_STORAGE_OVERLAY_CONTENT_TYPE, type);
        }

        function hideMediaOverlay() {
            mediaOverlay.classList.remove('visible');
            const overlayVideo = overlayContentWrapper.querySelector('video');
            if (overlayVideo) {
                overlayVideo.pause();
                // We don't reset currentTime here if the user closed it, they might want to continue
            }
            overlayContentWrapper.innerHTML = '';
            // Clear overlay state from localStorage
            localStorage.removeItem(LOCAL_STORAGE_OVERLAY_VISIBLE);
            localStorage.removeItem(LOCAL_STORAGE_OVERLAY_CONTENT_SRC);
            localStorage.removeItem(LOCAL_STORAGE_OVERLAY_CONTENT_TYPE);
            localStorage.removeItem(LOCAL_STORAGE_OVERLAY_CONTENT_CURRENT_TIME);
        }

        function restoreOverlayState() {
            const isOverlayVisible = localStorage.getItem(LOCAL_STORAGE_OVERLAY_VISIBLE) === 'true';
            if (isOverlayVisible) {
                const src = localStorage.getItem(LOCAL_STORAGE_OVERLAY_CONTENT_SRC);
                const type = localStorage.getItem(LOCAL_STORAGE_OVERLAY_CONTENT_TYPE);
                const currentTime = parseFloat(localStorage.getItem(LOCAL_STORAGE_OVERLAY_CONTENT_CURRENT_TIME) || '0');
                if (src && type) {
                    showMediaInOverlay(src, type, currentTime);
                } else {
                    hideMediaOverlay(); // Fallback if data is incomplete
                }
            }
        }

        function cleanUpAllMedia() {
            document.querySelectorAll('.image-slide').forEach(slide => {
                const index = parseInt(slide.dataset.index);
                const frame = slide.querySelector('.dragon-frame');
                const frontVideo = slide.querySelector('.dragon-front video');
                const backVideo = slide.querySelector('.dragon-back video');
                
                const isCurrentSlide = slide.classList.contains('current');
                const isFlipped = frame.classList.contains('flipped');

                // Clear any ongoing video time update intervals
                if (videoTimeUpdateIntervals[index]) {
                    clearInterval(videoTimeUpdateIntervals[index]);
                    delete videoTimeUpdateIntervals[index];
                }

                if (frontVideo) {
                    frontVideo.pause();
                    frontVideo.muted = true;
                    // No need to reset currentTime for front video, it's decorative
                }

                if (backVideo) {
                    if (isCurrentSlide && isFlipped) {
                        // If it's the current, flipped card, do not pause or reset.
                        // It's meant to be actively playing.
                        backVideo.muted = false; // Ensure it's unmuted
                    } else {
                        backVideo.pause();
                        backVideo.currentTime = 0; // Reset video to start
                        backVideo.muted = true;
                        localStorage.setItem(LOCAL_STORAGE_VIDEO_TIME + index, '0'); // Reset saved time
                    }
                }

                // If a card is not the current slide OR is current but not flipped, unflip it.
                // This ensures only the active, potentially flipped card remains in that state.
                if (!isCurrentSlide || (isCurrentSlide && !isFlipped)) {
                    frame.classList.remove('flipped');
                    let savedFlippedState = JSON.parse(localStorage.getItem(LOCAL_STORAGE_FLIPPED_STATE) || '{}');
                    savedFlippedState[index] = false;
                    localStorage.setItem(LOCAL_STORAGE_FLIPPED_STATE, JSON.stringify(savedFlippedState));
                }
            });
            hideMediaOverlay(); // Always hide overlay when navigating carousel
        }


        function updateInfoSection() {
            const infoSectionContent = document.querySelector('.info-section');
            const currentDragon = dragonData[currentIndex];
            infoSectionContent.innerHTML = `
                <h2 class="dragon-name">${currentDragon.name}</h2>
                <p class="dragon-description">${currentDragon.description}</p>
            `;
        }

        function updateCarousel() {
            const imageSlides = document.querySelectorAll('.image-slide');
            const dots = document.querySelectorAll('.milkybar-dot');

            if (imageSlides.length === 0) return;
            slideFullWidth = imageSlides[0].offsetWidth;

            const carouselWidth = imageTrack.parentElement.offsetWidth;
            const slidesCount = dragonData.length;

            let translateXValue = (carouselWidth / 2) - (slideFullWidth / 2);
            translateXValue -= currentIndex * slideFullWidth;

            imageTrack.style.transform = `translateX(${translateXValue}px)`;
            dots.forEach((dot, index) => dot.classList.toggle('active', index === currentIndex));
            updateInfoSection();

            // Save current index to localStorage
            localStorage.setItem(LOCAL_STORAGE_CURRENT_INDEX, currentIndex.toString());

            imageSlides.forEach((slide, index) => {
                slide.classList.remove('current', 'prev', 'next', 'far-prev', 'far-next');

                let distance = index - currentIndex;
                if (distance > slidesCount / 2) distance -= slidesCount;
                else if (distance < -slidesCount / 2) distance += slidesCount;

                switch(distance) {
                    case 0: slide.classList.add('current'); break;
                    case 1: slide.classList.add('next'); break;
                    case -1: slide.classList.add('prev'); break;
                    case -2: slide.classList.add('far-prev'); break;
                    case 2: slide.classList.add('far-next'); break;
                }

                const frontVideo = slide.querySelector('.dragon-front video');
                const backVideo = slide.querySelector('.dragon-back video');
                const frame = slide.querySelector('.dragon-frame');
                const isFlipped = frame.classList.contains('flipped');


                if (frontVideo) {
                    frontVideo.muted = true; // Always muted on front
                    if (slide.classList.contains('current') && !isFlipped) {
                        frontVideo.play().catch(e=>console.warn("Front video autoplay prevented (current):", e));
                    } else {
                        frontVideo.pause();
                    }
                }

                if (backVideo) {
                    // Only manage back video if it's the current slide
                    if (slide.classList.contains('current') && isFlipped) {
                        backVideo.muted = false; // Unmute if current and flipped
                        backVideo.play().catch(e => console.warn("Back video autoplay prevented (current flipped):", e));
                    } else {
                        // Pause and reset if not the current *active* back video
                        backVideo.pause();
                        backVideo.currentTime = 0;
                        backVideo.muted = true;
                        localStorage.setItem(LOCAL_STORAGE_VIDEO_TIME + index, '0'); // Reset saved time
                    }
                }
            });
        }

        function goToSlide(index) {
            cleanUpAllMedia(); // Clean up all media states before changing slide
            currentIndex = index;
            updateCarousel();
        }

        function nextSlide() {
            cleanUpAllMedia();
            currentIndex = (currentIndex + 1) % dragonData.length;
            updateCarousel();
        }

        function prevSlide() {
            cleanUpAllMedia();
            currentIndex = (currentIndex - 1 + dragonData.length) % dragonData.length;
            updateCarousel();
        }

        prevButton.addEventListener('click', prevSlide);
        nextButton.addEventListener('click', nextSlide);
        mediaOverlay.addEventListener('click', hideMediaOverlay);
        overlayContentWrapper.addEventListener('click', e => e.stopPropagation());

        let touchStartX = 0;
        let touchEndX = 0;
        imageTrack.addEventListener('touchstart', (e) => {
            if (mediaOverlay.classList.contains('visible')) return; // Prevent swipe if overlay is open
            touchStartX = e.changedTouches[0].screenX;
        }, { passive: true });
        imageTrack.addEventListener('touchend', (e) => {
            if (mediaOverlay.classList.contains('visible')) return; // Prevent swipe if overlay is open
            touchEndX = e.changedTouches[0].screenX;
            const threshold = 50;
            if (touchEndX < touchStartX - threshold) nextSlide();
            else if (touchEndX > touchStartX + threshold) prevSlide();
        }, { passive: true });

        document.addEventListener('keydown', (e) => {
            if (mediaOverlay.classList.contains('visible')) {
                if (e.key === 'Escape') hideMediaOverlay();
                return; // Prevent carousel navigation if overlay is open
            }
            if (e.key === 'ArrowRight') nextSlide();
            if (e.key === 'ArrowLeft') prevSlide();
            if (e.key === 'Escape') {
                 // If a card is flipped, unflip it first. Otherwise, do nothing.
                const currentFlippedCard = document.querySelector('.image-slide.current .dragon-frame.flipped');
                if (currentFlippedCard) {
                    currentFlippedCard.click(); // Simulate click to unflip
                }
            }
        });

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                initCarousel();
                updateCarousel(); // Re-render and update positions
                restoreOverlayState(); // Restore overlay if it was open
            }, 200);
        });

        document.addEventListener('DOMContentLoaded', () => {
            initCarousel(); // Initializes the carousel and restores basic states
            updateCarousel(); // Ensures all current/prev/next classes are applied and media states are correct
            restoreOverlayState(); // Restores the media overlay state if it was open

            const isTouchDevice = window.matchMedia('(hover: none)').matches;
            if(isTouchDevice) {
                [prevButton, nextButton].forEach(button => {
                    button.addEventListener('touchstart', () => button.classList.add('glow-active'));
                    button.addEventListener('animationend', () => button.classList.remove('glow-active'));
                });
            }
        });
    </script>
</body>
</html>
